---
title: "Critical Habitat Raster"
author: "Kyle Lochhead"
date: "August 20, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(data.table)
library (here)
source (here ("R/functions/R_Postgres.R"))
library(tidyverse)
prov.rast <- raster::raster(
  nrows = 15744, ncols = 17216, xmn = 159587.5, xmx = 1881187.5, ymn = 173787.5, ymx = 1748187.5, 
  crs = st_crs(getSpatialQuery("Select * from bc_carib_poly_20090904 limit 1"))$proj4string, resolution = c(100, 100), vals = 0)
```

## Purpose
Here we develop rasters that specify the location of caribou herds and critical habitat types across British Columbia. When running the dataLoaderCLUS module, the herd and critical habitat areas that overlap the timber supply unit of interest get imported into the output SQLite database as 'zones' columns in the 'pixels' table of the database (see [dataLoaderCLUS](https://github.com/bcgov/clus/tree/master/R/SpaDES-modules/dataLoaderCLUS)). These data provide spatial areas to summarize information and apply constraints related to caribou, for example, habitat disturbance indicators.   

Caribou herd boundaries are essentially the outer spatial boundaries of habitat used by an ecologically similar group or 'sub-population' of caribou, and they are typically surveyed together to estimate population numbers.    

Caribou critical habitat has not been defined for all cariobu herds in BC, but where it has been delineated, it typically occurs within herd boundaries, is divided into various types, including:
- high elevation winter and summer range (HEWSR)
- high elevation winter range (HEWR)
- high elevation summer range (HESR)
- low elevation winter range (LEWR)
- low elevation summer range (LESR)
- matrix

Caribou critical habitat boudnaries have been defined independently by the government of Canada and more recently, by the government of British Columbia. Both types are created below.

## Caribou critical habitat
### British Columbia
- delineated by provincial cariou biologists 
- this data is currently (as of June 2020) 'draft' and not for distribution
- data was obtained from Nicola Dodd, Knowledge Management Branch, MoE; they are the data custodians  

#### Scenario 1
- below is for a scenario where  no harvest in high elevation, 15% max disturbance in low elevation, 35% max disturbance in matrix in BC critical habitat

```{r, scenario: bc critical habitat, no harvest in high elevation, 15% max disturbance in low elevation, 35% max disturbance in matrix}
# BC critical habitat 
#bc.crit<-getSpatialQuery("SELECT * from bc_caribou_core_matrix_habitat_v20190904_1;") # old version
bc.crit<-getSpatialQuery("SELECT * from bc_caribou_linework_v20200507_shp_core_matrix;") # spatial critical habitat polygon data

#all - create the raster for each herd and critical habitat type
all.bc<-bc.crit

all.bc$crithab<-paste(all.bc$herd_name, all.bc$bchab_code) # create unique id ("value") for each unique herd name and habitat type
all.vat<-data.table(unique(all.bc$crithab))
setnames(all.vat, "V1", "crithab")
all.vat[, value:= seq_len(.N)]
conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", "criticalhabitat_bc_vat"), value= all.vat, row.names = FALSE, overwrite = TRUE)
dbDisconnect(conn)

all.bc2<-merge(all.bc, all.vat, by.x = "crithab",by.y = "crithab") # merge id with the polygon data

ras.all.bc <-fasterize::fasterize(all.bc2, prov.rast, field = "value") # rasterzie the polygon data to the provicnal raster
writeRaster(ras.all.bc, "bccrithab.tif", overwrite = TRUE)
system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/bccrithab.tif -t 100x100 rast.bc_crithab | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

#c("Rainbows","Charlotte_Alplands", "Itcha_Ilgachuz", "Groundhog", "Monashee", "Barkerville",  "Telkwa", "Central_Rockies","Central_Selkirks","Columbia_North","Columbia_South","Frisby_Boulder", "Purcell_Central","Purcell_South","South_Selkirks","Wells_Gray_South","Narrow_Lake","North_Cariboo","Wells_Gray_North","Hart_Ranges","Redrock_Prairie_Creek")
herds<-c("Barkerville", "Graham", "Groundhog",  "Moberly",  "Burnt_Pine", "Monashee","Narraway", "Quintette" ,  "Rainbows", "Telkwa",  "Itcha_Ilgachuz",  "Central_Rockies", "Central_Selkirks" ,  "Charlotte_Alplands", "Columbia_North", "Columbia_South", "Frisby_Boulder","Hart_Ranges",         "Kennedy_Siding","Narrow_Lake", "North_Cariboo" , "Purcell_Central",  "Purcells_South", "South_Selkirks", "Wells_Gray_North", "Wells_Gray_South", "Redrock_Prairie_Creek") # list of herd names in the polygon data; can customize the list to add/remove

#herds<-c("Narrow_Lake","North_Cariboo")
for(herd in herds){ # create a table of the constraints for each herd
  bc.crit.selected<-eval(parse(text = paste0("bc.crit[bc.crit$herd_name == '", 
                                             herd,"',]")))
  vat<-data.table(unique(bc.crit.selected$bchab_code)) # create value table for each unique herd name and habitat type  
  setnames(vat, "V1", "crithab")
  vat[, zoneid:= seq_len(.N)]
  
  conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
  DBI::dbWriteTable(conn, c("public", paste0("criticalhabitat_",tolower(herd),"_vat")), value= vat, row.names = FALSE, overwrite = TRUE)
  dbDisconnect(conn)
  
  bc.crit.selected2 <-merge(bc.crit.selected, vat, by.x = "bchab_code",by.y = "crithab") # merge id with the polygon data
  ras.bc.crit.selected <-fasterize::fasterize(bc.crit.selected2, prov.rast, field = "zoneid") #

  eccc.vat<-vat # create a constraint for a specific scenario; here the scenario is "ECCC" for the federal recovery plan 
  eccc.vat[, reference_zone:= paste0('rast.zone_cond_eccc_', tolower(herd),'_crithab')] # zone name field
  eccc.vat[, variable:= 'dist'] # 'dist' is the distance to constraint type
  eccc.vat[, type:= 'ge'] # greater than or equal to (ge), less than or equal to (le)
  eccc.vat[, ndt:= 0]
  eccc.vat[, threshold:= 500] # threshold from disturbance (500 m)
  eccc.vat[ crithab %in% c('Matrix'), percentage:= 85] # percentage of area where constraint applies, e.g., in this case, 85% ge 500m
  eccc.nh.zones<-eccc.vat[is.na(percentage), zoneid] # where there is no constaint, make it a 'no harvest' zone
  
  ras.eccc<-ras.bc.crit.selected
  ras.eccc[ras.eccc[] %in% eccc.nh.zones]<-0
  
  zone.eccc.crithab<-eccc.vat[!(zoneid %in% eccc.nh.zones),]
  zone.eccc.crithab<-zone.eccc.crithab[, c('zoneid', 'reference_zone', 'ndt', 'variable', 'threshold','type','percentage' )]
  zone.eccc.crithab.nh<-data.table(zoneid =0, reference_zone = paste0('rast.zone_cond_eccc_', tolower(herd),'_crithab'), ndt =0, variable ='', threshold = 0, type = 'nh', percentage =0)

  zone.eccc.crithab<-rbindlist(list(zone.eccc.crithab, zone.eccc.crithab.nh))
  writeRaster(ras.eccc, "rasecccrit.tif", overwrite = TRUE)

  zone.eccc.crithab<-zone.eccc.crithab[,zoneid:=as.integer(zoneid)]
  zone.eccc.crithab<-zone.eccc.crithab[,ndt:=as.integer(ndt)]
  zone.eccc.crithab<-zone.eccc.crithab[,threshold:=as.numeric(threshold)]

  conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

  DBI::dbWriteTable(conn, c("public", paste0("zone_eccc_",tolower(herd),"_crithab")), value= zone.eccc.crithab, row.names = FALSE, overwrite = TRUE)
 dbExecute(conn, paste0("ALTER TABLE zone_eccc_",tolower(herd),"_crithab INHERIT zone_constraints"))
 dbDisconnect(conn)

#upload to db
  system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/rasecccrit.tif -t 100x100', paste0(' rast.zone_cond_eccc_', tolower(herd),'_crithab'),' | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)


  bc.vat<-vat
  bc.vat[, reference_zone:= paste0('rast.zone_cond_bc_', tolower(herd),'_crithab')]
  bc.vat[, variable:= 'dist']
  bc.vat[, type:= 'ge']
  bc.vat[, threshold:= 500]
  bc.vat[ crithab %in% c('Matrix'), percentage:= 65]
  bc.vat[ crithab %in% c('Matrix'), threshold:= 0]
  bc.vat[ crithab %in% c('LEWR', 'LEWSR'), percentage:= 85]
  bc.nh.zones<-bc.vat[is.na(percentage), zoneid]
  
  ras.bc<-ras.bc.crit.selected
  ras.bc[ras.bc[] %in% bc.nh.zones]<-0
  writeRaster(ras.bc, "rasbccrit.tif", overwrite = TRUE)
  
  zone.bc.crithab<-bc.vat[!(zoneid %in% bc.nh.zones),]
  zone.bc.crithab<-zone.bc.crithab[, c('zoneid', 'reference_zone', 'ndt', 'variable', 'threshold','type','percentage' )]
  zone.bc.crithab.nh<-data.table(zoneid =0, reference_zone = paste0('rast.zone_cond_bc_', tolower(herd),'_crithab'), ndt =0, variable ='', threshold = 0, type = 'nh', percentage =0)

  zone.bc.crithab<-rbindlist(list(zone.bc.crithab, zone.bc.crithab.nh))
  zone.bc.crithab<-zone.bc.crithab[,zoneid:=as.integer(zoneid)]
  zone.bc.crithab<-zone.bc.crithab[,ndt:=as.integer(ndt)]
  zone.bc.crithab<-zone.bc.crithab[,threshold:=as.numeric(threshold)]
  
  conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

  DBI::dbWriteTable(conn, c("public", paste0("zone_bc_",tolower(herd),"_crithab")), value= zone.bc.crithab, row.names = FALSE, overwrite = TRUE)
 dbExecute(conn, paste0("ALTER TABLE zone_bc_",tolower(herd),"_crithab INHERIT zone_constraints"))
 dbDisconnect(conn)

#upload to db
  system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/rasbccrit.tif -t 100x100', paste0(' rast.zone_cond_bc_', tolower(herd),'_crithab'),' | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

}


```


#### Scenario 2
- below is for a scenario where there is no harvest in any BC critical habitat

```{r, scenario: bc critical habitat, no harvest}
#Canadian (Federal) contraints
bc.crit<-getSpatialQuery("SELECT * from bc_caribou_core_matrix_habitat_v20190904_1;")

herds<-c("Rainbows","Charlotte_Alplands", "Itcha_Ilgachuz", "Barkerville", "Wells_Gray_South","Narrow_Lake","North_Cariboo","Wells_Gray_North")

for(herd in herds){
bc.crit.selected<-eval(parse(text = paste0("bc.crit[bc.crit$herd_name == '", 
                                             herd,"',]")))
bc.crit.selected$zoneid<-0
  
ras.bc.crit.selected <-fasterize::fasterize(bc.crit.selected, prov.rast, field = "zoneid")
writeRaster(ras.bc.crit.selected , "rasnhcrit.tif", overwrite = TRUE)

zone.eccc.crithab<-data.table(zoneid =0, reference_zone = paste0('rast.zone_cond_nh_crit_', tolower(herd),'_crithab'), ndt =0, variable ='', threshold = 0, type = 'nh', percentage =0) # makes each zone no harvest
zone.eccc.crithab<-zone.eccc.crithab[,zoneid:=as.integer(zoneid)]
zone.eccc.crithab<-zone.eccc.crithab[,ndt:=as.integer(ndt)]
zone.eccc.crithab<-zone.eccc.crithab[,threshold:=as.numeric(threshold)]

conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

DBI::dbWriteTable(conn, c("public", paste0("zone_nh_crit_",tolower(herd),"_crithab")), value= zone.eccc.crithab, row.names = FALSE, overwrite = TRUE)
 dbExecute(conn, paste0("ALTER TABLE zone_nh_crit_",tolower(herd),"_crithab INHERIT zone_constraints"))
 dbDisconnect(conn)

#upload to db
  system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/rasnhcrit.tif -t 100x100', paste0(' rast.zone_cond_nh_crit_', tolower(herd),'_crithab'),' | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

}
```

#### Scenario 3
- below is for a scenario where there is no harvest BC herd boundaries

```{r, scenario: bc herd boundaries, no harvest}

bc.bounds <- getSpatialQuery("SELECT * from bc_caribou_herd_boundary_v20200507;") # data from caribou prorgam; uploaded into postgres via ogr2ogr
herds <- c(unique (bc.bounds$herd_name))

for (herd in herds){
bc.bounds.selected <- eval (parse (text = paste0("bc.bounds[bc.bounds$herd_name == '", 
                                          herd,"',]")))
bc.bounds.selected$zoneid <- 0
  
ras.bc.bounds.selected <- fasterize::fasterize (bc.bounds.selected, prov.rast, field = "zoneid")
writeRaster (ras.bc.bounds.selected , "ras_herd_bounds.tif", overwrite = TRUE)

zone.bc.bounds.nh <- data.table (zoneid = 0, # zoneid of 0 makes each zone no harvest
                                 reference_zone = paste0('rast.zone_bc_bounds_', tolower(herd),'_noharvest'), 
                                 ndt = 0, variable = '', threshold = 0, type = 'nh', percentage = 0, 
                                 multi_condition = NA) 
zone.bc.bounds.nh <- zone.bc.bounds.nh [, zoneid := as.integer (zoneid)]
zone.bc.bounds.nh <- zone.bc.bounds.nh [, ndt := as.integer (ndt)]
zone.bc.bounds.nh <- zone.bc.bounds.nh [, threshold := as.numeric (threshold)]

conn <- DBI::dbConnect (dbDriver ("PostgreSQL"), 
                        host = keyring::key_get ('dbhost', keyring = 'postgreSQL'), 
                        dbname = keyring::key_get ('dbname', keyring = 'postgreSQL'), 
                        port = '5432',
                        user = keyring::key_get ('dbuser', keyring = 'postgreSQL'),
                        password = keyring::key_get ('dbpass', keyring = 'postgreSQL'))

DBI::dbWriteTable (conn, c("public", paste0("zone_bc_bounds_",tolower(herd),"_nh")), # 
                   value = zone.bc.bounds.nh, row.names = FALSE, overwrite = TRUE)
dbExecute (conn, paste0 ("ALTER TABLE zone_bc_bounds_", tolower (herd),"_nh INHERIT zone_constraints"))
dbDisconnect (conn)

#upload to db
system ("cmd.exe", 
        input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', 
                       here::here(), '/R/Params/ras_herd_bounds.tif -t 100x100 ', 
                       paste0('rast.zone_bc_bounds_', tolower(herd),'_noharvest'),' | psql postgres://', 
                       keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', 
                       keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', 
                       keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), 
        show.output.on.console = FALSE, invisible = TRUE)

}
```

#### Scenario 4
- below is for a scenario that combines herds with and without critical habitat data
- first I combined recent critical habitat and herd data together in ArcGIS, using "Merge" 
- I created "BCHab_code" and "BC_Habitat_Type" fields in the herd boundary data, consistent with the critical habitat data, and  defined them as "No critical habitat" and "None"
- thus we have critical habitat defined for each herd in a single shapefile
- located [here](\\spatialfiles2.bcgov\archive\FOR\VIC\HTS\ANA\PROJECTS\CLUS\Data\caribou\bc_critical_habitat\bc_crit_habitat_and_herds_v20200615.gdb), as 'bc_critical_habitat_all_herds_20200615'
- also loaded into postgres using ogr2ogr


```{r, scenario: bc critical habitat and herd boundaries,  no harvest in high and low elevation, 35% max disturbance in matrix}

bc.habitat <- getSpatialQuery("SELECT * from bc_critical_habitat_all_herds_20200615;") # data from caribou prorgam; uploaded into postgres via ogr2ogr
herds <- c(unique (bc.habitat$herd_name))

#all - create the raster for each herd and critical habitat type
all.bc <- bc.habitat
all.bc$crithab <- paste(all.bc$herd_name, all.bc$bchab_code) # create unique id ("value") for each unique herd name and habitat type

all.vat <- data.table (unique (all.bc$crithab))
setnames (all.vat, "V1", "crithab")
all.vat [, value := seq_len (.N)] # assign number to each unique herd-habitat comibnation

conn <- DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", "vat_bc_crithab_and_herd"), value= all.vat, row.names = FALSE, overwrite = TRUE)
dbDisconnect(conn)

all.bc2 <- merge (all.bc, all.vat, by.x = "crithab", by.y = "crithab") # merge number id with the polygon data
ras.all.bc <- fasterize::fasterize (all.bc2, prov.rast, field = "value") # rasterize the polygon data to the provincial raster
writeRaster(ras.all.bc, "bccrithab.tif", overwrite = TRUE)
system ("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/bccrithab.tif -t 100x100 rast.bc_crithab_and_herd | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

herds <- c (unique (bc.habitat$herd_name))

for (herd in herds) { # create a table of the constraints for each herd; here we are applying 35% disturbance to Matrix, and 0% disturbance everywhere else; these can be updated later
  bc.selected <- eval (parse (text = paste0("bc.habitat [bc.habitat$herd_name == '", 
                                            herd,"',]")))
  vat <- data.table (unique (bc.selected$bchab_code)) # create value table for each unique herd name and habitat type  
  setnames (vat, "V1", "crithab")
  vat [, zoneid:= seq_len(.N)]
  
  conn <- DBI::dbConnect(dbDriver("PostgreSQL"), 
                         host=keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                         dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                         port = '5432',
                         user=keyring::key_get('dbuser', keyring = 'postgreSQL'),
                         password= keyring::key_get('dbpass', keyring = 'postgreSQL'))
  DBI::dbWriteTable (conn, c("public", paste0 ("vat_criticalhabitat_", tolower(herd))), 
                     value = vat, row.names = FALSE, overwrite = TRUE)
  dbDisconnect (conn)
  
  bc.selected2 <- merge (bc.selected, vat, by.x = "bchab_code", by.y = "crithab") # merge id with the polygon data
  
  ras.bc.selected <- fasterize::fasterize (bc.selected2, prov.rast, field = "zoneid") #

#### ECCCC ####
  eccc.vat <- vat # create a constraint for a specific scenario; here the scenario is "ECCC" for the federal recovery plan 
  eccc.vat [, reference_zone := paste0 ('rast.zone_cond_eccc_', tolower(herd),'_crithab_or_herd')] # zone name field
  eccc.vat [, variable := 'dist'] # 'dist' is the distance to constraint type
  eccc.vat [, type := 'ge'] # greater than or equal to (ge), less than or equal to (le)
  eccc.vat [, ndt := 0]
  eccc.vat [, threshold := 500] # threshold from disturbance (500 m)
  eccc.vat [, multi_condition := NA]
  eccc.vat [ crithab %in% c('Matrix'), percentage := 85] # percentage of area where constraint applies, e.g., in this case, 85% ge 500m
  eccc.nh.zones <- eccc.vat [is.na (percentage), zoneid] # where there is no constraint, make it a 'no harvest' zone
  
  ras.eccc <- ras.bc.selected
  ras.eccc [ras.eccc[] %in% eccc.nh.zones] <- 0
  
  zone.eccc.crithab <- eccc.vat[!(zoneid %in% eccc.nh.zones),]
  zone.eccc.crithab <- zone.eccc.crithab [, c('zoneid', 'reference_zone', 'ndt', 'variable',
                                              'threshold', 'type', 'percentage', 'multi_condition')]
  zone.eccc.crithab.nh <- data.table (zoneid = 0, 
                                      reference_zone = paste0 ('rast.zone_cond_eccc_', 
                                                               tolower(herd),'_crithab_or_herd'), 
                                      ndt = 0, variable = '', threshold = 0, type = 'nh', 
                                      percentage = 0,
                                      multi_condition = NA)

  zone.eccc.crithab <- rbindlist (list (zone.eccc.crithab, zone.eccc.crithab.nh))
  writeRaster (ras.eccc, "ras_eccc_crit_or_herd.tif", overwrite = TRUE)

  zone.eccc.crithab <- zone.eccc.crithab [, zoneid := as.integer (zoneid)]
  zone.eccc.crithab <- zone.eccc.crithab [, ndt := as.integer (ndt)]
  zone.eccc.crithab <- zone.eccc.crithab [, threshold := as.numeric (threshold)]
  zone.eccc.crithab <- zone.eccc.crithab [, multi_condition := as.character (multi_condition)]

  conn<-DBI::dbConnect (dbDriver("PostgreSQL"), 
                       host = keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                       dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                       port = '5432' ,
                       user = keyring::key_get('dbuser', keyring = 'postgreSQL') ,
                       password = keyring::key_get('dbpass', keyring = 'postgreSQL'))

  DBI::dbWriteTable(conn, c("public", 
                            paste0("zone_eccc_",tolower(herd),"_crithab_or_herd")), 
                    value = zone.eccc.crithab, row.names = FALSE, overwrite = TRUE)
 dbExecute (conn, paste0("ALTER TABLE zone_eccc_",tolower(herd),"_crithab_or_herd INHERIT zone_constraints"))
 dbDisconnect(conn)

#upload to db
  system("cmd.exe", 
         input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', 
                        here::here(), '/R/params/ras_eccc_crit_or_herd.tif -t 100x100', 
                        paste0(' rast.zone_cond_eccc_', tolower(herd),'_crithab_or_herd'),' | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

  
  
#### no harvest ####
bc.bounds.selected <- bc.selected
bc.bounds.selected$zoneid <- 0 # zoneid = 0 sets zone as no harvest
  
ras.bc.bounds.selected <- fasterize::fasterize (bc.bounds.selected, prov.rast, field = "zoneid")
writeRaster (ras.bc.bounds.selected , "ras_herd_bounds_nh.tif", overwrite = TRUE)

zone.nh.crithab.herd <- data.table(zoneid = 0, # zone id = 0 makes it no harvest
                                   reference_zone = paste0('rast.zone_cond_noharvest_',
                                                           tolower(herd),'_crithab_or_herd'),
                                   ndt = 0, variable = '', threshold = 0, type = 'nh', percentage = 0,
                                   multi_condition = NA)
  
zone.nh.crithab.herd <- zone.nh.crithab.herd[, zoneid := as.integer(zoneid)]
zone.nh.crithab.herd <- zone.nh.crithab.herd[, ndt := as.integer (ndt)]
zone.nh.crithab.herd <- zone.nh.crithab.herd[, threshold := as.numeric (threshold)]
zone.nh.crithab.herd <- zone.nh.crithab.herd[, multi_condition := as.character (multi_condition)]

conn<-DBI::dbConnect(dbDriver("PostgreSQL"), 
                       host = keyring::key_get('dbhost', keyring = 'postgreSQL'), 
                       dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), 
                       port ='5432' ,
                       user = keyring::key_get('dbuser', keyring = 'postgreSQL') ,
                       password = keyring::key_get('dbpass', keyring = 'postgreSQL'))
DBI::dbWriteTable(conn, c("public", paste0 ("zone_noharvest_",tolower(herd),"_crithab_or_herd")), 
                    value = zone.nh.crithab.herd, row.names = FALSE, overwrite = TRUE)
dbExecute(conn, 
          paste0("ALTER TABLE zone_noharvest_",tolower(herd),"_crithab_or_herd INHERIT zone_constraints"))
dbDisconnect(conn)  
 
#upload to db
  system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', 
                                   here::here(), '/R/params/ras_herd_bounds_nh.tif -t 100x100', 
                                   paste0(' rast.zone_cond_noharvest_', tolower(herd),'_crithab_or_herd'),' | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)

}


```






---

## Fed line work

## Southern Mountain

### Central Group

The critical habitats may come in various data structure forms like .shp or .gdb. In this chunk the data is loaded in R.
```{r, sm.cg}
#Canadian (Federal) contraints
sm.cg.crit<-sf::st_read("S:/ANA/PROJECTS/CLUS/Data/caribou/critical_habitat/Canada/Southern_Mtn/Central_Group/data/DraftSMCcg_CHLPU_20181016/DraftCHLPU_20181016.gdb", layer ='CH_638_Rangifer_tarandus_caribou_SouthMountain_CentralGroup')

unique(sm.cg.crit$CHVariant)

sm.cg.crit<-sm.cg.crit[!is.na(sm.cg.crit$CHVariant), c("SHAPE", "CHVariant")] #keep only the needed features
sm.cg.crit<-st_zm(sm.cg.crit) #remove the z dimension
sm.cg.crit<-st_cast(sm.cg.crit, "MULTIPOLYGON") #cast to a multipolygon

sm.cg.crit3<-sm.cg.crit %>% group_by(CHVariant) %>% 
        summarise() #unique polygons for each CHVariant
sm.cg.crit3<-sm.cg.crit3[!(sm.cg.crit3$CHVariant == 'Connectivity Range'),]
st_write(sm.cg.crit3, "sm_cg.shp")

```
### Northern Group
```{r, sm.cg}
#Canadian (Federal) contraints
sm.ng.crit<-sf::st_read("S:/ANA/PROJECTS/CLUS/Data/caribou/critical_habitat/Canada/Southern_Mtn/Northern_Group/data/DraftSMCng_CHLPU_20181016/DraftCHLPU_20181016.gdb", layer ='CH_638_Rangifer_tarandus_caribou_SouthMountain_NorthernGroup')

unique(sm.ng.crit$CHVariant)

sm.ng.crit<-sm.ng.crit[!is.na(sm.ng.crit$CHVariant), c("SHAPE", "CHVariant")] #keep only the needed features
sm.ng.crit<-st_zm(sm.ng.crit) #remove the z dimension
sm.ng.crit<-st_cast(sm.ng.crit, "MULTIPOLYGON") #cast to a multipolygon
sm.ng.crit<-sm.ng.crit[!(sm.ng.crit$CHVariant == ''),]
  
sm.ng.crit3<-sm.ng.crit %>% group_by(CHVariant) %>% 
        summarise() #unique polygons for each CHVariant

sm.ng.crit3<-sm.ng.crit3[!(sm.ng.crit3$CHVariant == 'Connectivity Range'),]
st_write(sm.ng.crit3, "sm_ng.shp")

```
### Southern Group
```{r, sm.cg}
#Canadian (Federal) contraints
sm.sg.crit<-sf::st_read("S:/ANA/PROJECTS/CLUS/Data/caribou/critical_habitat/Canada/Southern_Mtn/Southern_Group/data/DraftSMCsg_CHLPU_20181016/DraftCHLPU_20181016.gdb", layer ='CH_638_Rangifer_tarandus_caribou_SouthMountain_SouthernGroup')

unique(sm.sg.crit$CHVariant)

sm.sg.crit<-sm.sg.crit[!is.na(sm.sg.crit$CHVariant), c("Shape", "CHVariant")] #keep only the needed features
sm.sg.crit<-st_zm(sm.sg.crit) #remove the z dimension
sm.sg.crit<-st_cast(sm.sg.crit, "MULTIPOLYGON") #cast to a multipolygon
sm.sg.crit<-sm.sg.crit[!(sm.sg.crit$CHVariant == ''),]
sm.sg.crit<-sm.sg.crit[!is.null(sm.sg.crit$CHVariant),]
  
sm.sg.crit3<-sm.sg.crit %>% group_by(CHVariant) %>% 
        summarise() #unique polygons for each CHVariant

sm.sg.crit3<-sm.sg.crit3[!(sm.sg.crit3$CHVariant == 'Connectivity Range'),]
sm.sg.crit3<-sm.sg.crit3[!(sm.sg.crit3$CHVariant == 'Matrix Range'),]
st_write(sm.sg.crit3, "sm_sg.shp")

```

## Rasterize critical habitat types
The critical habitat spatial zones need to be rasterized to the same extent as the other layers to ensure that the pixels match

```{r, rasterize}
#Make a dummy raster with the same extent as the other provincial rasters
#build a default/empty provincial raster
sm.ng<-st_read(paste0(here::here(),"/R/Params/sm_ng.shp"))
sm.cg<-st_read(paste0(here::here(),"/R/Params/sm_cg.shp"))
sm.sg<-st_read(paste0(here::here(),"/R/Params/sm_sg.shp"))

sm<-rbind(sm.ng,sm.cg,sm.sg)
unique(sm$CHVariant)
sm1<-sm[sm$CHVariant %in% c('Matrix Range', 'High Elevation Winter/Summer Range', 'Low Elevation Summer Range',  'High Elevation Winter Range', 'Core Range', 'Low Elevation Winter Range' ),]

crit.vat<-data.table(CHVariant=unique(sm1$CHVariant))
crit.vat[, critid:=seq_len(.N)]

sm2<-merge(sm1, crit.vat)

#rasterize the critical habitat

ras.sm <-fasterize::fasterize(sm2, prov.rast, field = "critid") #this is a
raster::plot(ras.sm)
```

## Caribou Herds or LPUs 
```{r, carib}
carib_poly<-getSpatialQuery("SELECT herd_name, wkb_geometry from bc_carib_poly_20090904;")
carib.vat<-data.table(herd_name=unique(carib_poly$herd_name))
carib.vat[,caribid := seq_len(.N)*10]#multiply by 10 so the first digit can be a unique critical habitat (1-6)
carib_poly2<-merge(carib_poly,carib.vat)

#Create a provincial raster
prov.rast <- raster::raster(
  nrows = 15744, ncols = 17216, xmn = 159587.5, xmx = 1881187.5, ymn = 173787.5, ymx = 1748187.5, 
  crs = st_crs(carib_poly)$proj4string, resolution = c(100, 100), vals = 0)

ras.carib <-fasterize::fasterize(carib_poly2, prov.rast, field = "caribid") 
raster::plot(ras.carib)
```
## Create the zone raster
```{r, zon.ras}
ras.sm[is.na(ras.sm[])]<-0
ras.carib[is.na(ras.carib[])]<-0
ras.zone<-ras.sm+ras.carib

#Clip to the bc boundary
bcb <-bcmaps::bc_bound_hres()
bcb$bc <-1
ras.bc <-fasterize::fasterize(bcb, prov.rast, field = "bc") 
ras.zone <-ras.zone*ras.bc


test<-data.table(freq(ras.zone))
test[, critid:= as.integer(substr(as.character(value), nchar(as.character(value)), nchar(as.character(value))))] 

#get rid of the pixels that do not have a critical habitat
remove<-test[critid == 0, value]
ras.zone[ras.zone[] %in% remove]<-NA

#create the value attribute table (vat)
sm.vat<- test[!(critid == 0), ]
sm.vat[,caribid:= value - critid] #get the caribou herd identifier
sm.vat<-merge(sm.vat, carib.vat, all.x = TRUE)
sm.vat<-merge(sm.vat, crit.vat, all.x = TRUE, by.x = 'critid', by.y ='critid')

#zoneid reference_zone ndt variable threshold type percentage
setnames(sm.vat, "value", "zoneid")
sm.vat[, reference_zone:= 'rast.zone_cond_crithab']
sm.vat[, variable:= 'age']
sm.vat[, type:= 'le']
sm.vat[, threshold:= '40']

sm.vat[CHVariant == 'Matrix Range', percentage:= 18]
sm.vat[CHVariant == 'Low Elevation Winter Range', percentage:= 18]

nh.zones<-sm.vat[is.na(percentage), zoneid]
ras.zone[ras.zone[] %in% nh.zones]<-0

zone.crithab<-sm.vat[!(zoneid %in% nh.zones),]
zone.crithab<-zone.crithab[,ndt:=0]

zone.crithab<-zone.crithab[, c('zoneid', 'reference_zone', 'ndt', 'variable', 'threshold','type','percentage' )]
zone.crithab.nh<-data.table(zoneid =0, reference_zone = 'rast.zone_cond_crithab', ndt =0, variable ='', threshold = 0, type = 'nh', percentage =0)

zone.crithab<-rbindlist(list(zone.crithab, zone.crithab.nh))

writeRaster(ras.zone, "test.tif", overwrite = TRUE)
```



## Commit to postgreSQL
```{r, commit_db}

conn<-DBI::dbConnect(dbDriver("PostgreSQL"), host=keyring::key_get('dbhost', keyring = 'postgreSQL'), dbname = keyring::key_get('dbname', keyring = 'postgreSQL'), port='5432' ,user=keyring::key_get('dbuser', keyring = 'postgreSQL') ,password= keyring::key_get('dbpass', keyring = 'postgreSQL'))

zone.crithab<-zone.crithab[,zoneid:=as.integer(zoneid)]
zone.crithab<-zone.crithab[,ndt:=as.integer(ndt)]
zone.crithab<-zone.crithab[,threshold:=as.numeric(threshold)]
DBI::dbWriteTable(conn, c("public", "zone_crithab"), value= zone.crithab, row.names = FALSE, overwrite = TRUE)

#dbExecute(conn, "ALTER TABLE zone_vqo INHERIT zone_constraints")
dbDisconnect(conn)

#upload to db
system("cmd.exe", input = paste0('raster2pgsql -s 3005 -d -I -C -M -N 2147483648  ', here::here(), '/R/params/test.tif -t 100x100 rast.zone_cond_crithab | psql postgres://', keyring::key_get('dbuser', keyring = 'postgreSQL'), ':', keyring::key_get('dbpass', keyring = 'postgreSQL'), '@', keyring::key_get('dbhost', keyring = 'postgreSQL'), ':5432/clus'), show.output.on.console = FALSE, invisible = TRUE)
```





